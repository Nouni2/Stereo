
import cv2 as cv
import numpy as np
import os

if cv.useOptimized():
    print("Opencv : Optimized")
else:
    print("Opencv : Not optimized")


def getAffHomography(SuppG_path, SuppD_path, method):
    """ CALCULATES THE HOMOGRAPHY TRANSFORMATION
    THAT MUST BE APPLIED TO THE LEFT IMAGE

    Parameters:
    - SuppG_path: [string] Path to an OpenCV mat (cropped left image).
    - SuppD_path: [string] Path to an OpenCV mat (cropped right image).
    - method: [string] Either "Sift" or "Orb".

    Returns:
    - ndarray: The affine transformation matrix.

    This function calculates the homography transformation that must be applied
    to the left image to align it with the right image. It uses either the SIFT
    (Scale-Invariant Feature Transform) or ORB (Oriented FAST and Rotated BRIEF)
    method to detect keypoints and descriptors in the images. Then, it matches
    the descriptors using a Brute Force Matcher and finds the best points of
    interest. Finally, it estimates the affine transformation matrix using the
    RANSAC algorithm and returns it.
    """
    if method is None:
        "Method is missing, choose either 'SIFT' or 'ORB'"
    SuppG_color = cv.imread(SuppG_path)
    SuppD_color = cv.imread(SuppD_path)

    if SuppG_color.size==0:
        "File for the left image could not be read, check with os.path.exists()"
    if SuppD_color.size==0:
        "File for the right image could not be read, check with os.path.exists()"

    SuppG = cv.cvtColor(SuppG_color, cv.COLOR_BGR2GRAY)
    SuppD = cv.cvtColor(SuppD_color, cv.COLOR_BGR2GRAY)

    if method.upper() == 'SIFT':
        # SIFT detects keypoints and computes descriptors
        sift = cv.SIFT_create()
        kpg, desg = sift.detectAndCompute(SuppG, None)
        kpd, desd = sift.detectAndCompute(SuppD, None)
        # Create a Brute Force Matcher object with NORM_L2 suitable for SIFT
        bf = cv.BFMatcher(cv.NORM_L2, crossCheck=False)

    elif method.upper() == 'ORB':
        # ORB detects keypoints and computes descriptors
        orb = cv.ORB_create()
        kpg, desg = orb.detectAndCompute(SuppG, None)
        kpd, desd = orb.detectAndCompute(SuppD, None)
        # Create a Brute Force Matcher object with NORM_HAMMING suitable for ORB
        bf = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=False)

    else:
        print("Method does not exist")

    # Match descriptors using k-nearest neighbors method
    matches = bf.knnMatch(desg, desd, k=2)

    # Find the best keypoints
    good = []
    for m, n in matches:
        if m.distance < 0.7 * n.distance:
            good.append(m)
    good = sorted(good, key=lambda x: x.distance)

    # Extract keypoint locations and remove duplicates
    src_pts = np.float32([kpg[m.queryIdx].pt for m in good]).reshape(-1, 1, 2)
    dst_pts = np.float32([kpd[m.trainIdx].pt for m in good]).reshape(-1, 1, 2)

    # Calculate the affine transformation matrix to map keypoints from the left to the right image
    affineMatrix = cv.estimateAffine2D(src_pts, dst_pts, method=cv.RANSAC, ransacReprojThreshold=3)

    return affineMatrix[0]


def applyAffHomography(input,input_path,AffHomo):
    out_img = cv.warpAffine(input,AffHomo, (input.shape[1],input.shape[0]))
    cv.imwrite(input_path, out_img)
    return out_img
#M = getAffHomography("IMG_src/2029-1518-max_left.jpg","IMG_src/2029-1518-max_right.jpg",'SIFT')
#print(M)
