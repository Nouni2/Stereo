    #########################################################################################################
    #########################################################################################################
    ########   BOTH SVG FILE AND IMAGE FILE (.jpg, .png, .tiff, ...) MUST BE IN THE SAME DIRECTORY   ########
    #########################################################################################################
    #########################################################################################################
import xml.etree.ElementTree as ET
import re
import cv2 as cv
import numpy as np
import os
from utils.utils import *
def process_image_svg(svg_path):
    """
    EXTRACT FEATURES CONTAINED IN SVG FILE
    - [param] svg_path  {string} : path to the svg file

     Elle renvoie en sortie 7 éléments qui sont tous des listes
     0: une liste avec les dimensions de l'image width et height
     1: liste de coordonnées du contour de l'image de gauche
     2: liste de coordonnées du contour de l'image de droite
     3: liste de coordonnées du support
     4: liste de coefficients de la matrice d'homographie
     5: chemin d'accès à l'image (.jpg, .png,...)
    """
    # Charger le fichier SVG
    tree = ET.parse(svg_path)
    root = tree.getroot()

    # Trouver les balises associées aux id avec root.find, on utilise cette commande dans tout le programme
    image = root.find(".//*[@id='image']")

    # On extrait le nom du fichier image correspondant dans le svg
    base_name = str(image.get('{http://www.w3.org/1999/xlink}href'))
    if base_name == None :
        print("Chemin d'accès à l'image non spécifié")
    # image de référence
    base_list = svg_path.split('/')
    base_list.pop(-1)
    base_path = base_list.pop(0)+"/"
    if len(base_list)==0 :
        base_path = (os.path.normpath(os.path.join(base_path,base_name))).replace("\\","/")
    else :
        for i in base_list:
               base_path = os.path.join(base_path, i)
    base_path = (os.path.normpath(os.path.join(base_path, base_name))).replace("\\","/")
    print(base_path)
    img_base = cv.imread(base_path)
    if img_base is not None :
        print("L'image a été trouvée")
    else :
        print("L'image n'a pas été trouvée")

    w = int(float(image.get('width')))
    h = int(float(image.get('height')))
    #au cas ou la taille serait "632.23216" il peut pas passer à un entier à cause du point donc on convertit d'abord en float puis en int

    #récupération des éléments de la matrice d'homographie si elle est renseignée
    homo = image.get('homography')

    if homo is None:
        print("La matrice d'homographie n'est pas renseignée dans le fichier SVG")

    #On se place dans la catégorie qui nous intéresse avec l'identifiant id
    lefteye = root.find(".//*[@id='lefteye']")
    righteye = root.find(".//*[@id='righteye']")

    # Extraire les contenus
    contourGauche_str = lefteye.get('d')
    contourDroit_str = righteye.get('d')
    # !!!!!! get renvoie une chaine de caractère même si c'est que des chiffres!!!!!!

    # récupération des contours de chaque image
    # Utiliser une expression régulière pour extraire les nombres
    coord_list_gauche = re.findall(r'\d+', contourGauche_str)
    coord_list_droit = re.findall(r'\d+', contourDroit_str)

    # Convertir la liste de chaînes de caractères en une liste de tuples d'entiers
    coord_pairs_gauche = [(int(coord_list_gauche[i]), int(coord_list_gauche[i+1])) for i in range(0, len(coord_list_gauche), 2)]
    coord_pairs_droit = [(int(coord_list_droit[i]), int(coord_list_droit[i+1])) for i in range(0, len(coord_list_droit), 2)]

    # récupération du supports sur le même principe que ce qui précède
    # support = root.find(".//*[@id='support']")
    # support_str = support.get('d')
    # coord_list_support = re.findall(r'\d+', support_str)
    # coord_pairs_support = [(int(coord_list_support[i]), int(coord_list_support[i+1])) for i in range(0, len(coord_list_support), 2)]

    return [w,h], coord_pairs_gauche, coord_pairs_droit, 0,homo, base_path



def generation_crop(input_path, w,h ,output_path,coord_edges):
    ''' GENERATES INDIVIDUAL LEFT AND RIGHT IMAGES CROPPED FROM THE SUPPORT AND ITS FEATURES EXTRACTED
        FROM SVG FILE
    Version 21/04/2024 - 21:58
    - [param] input_path  {string} : path to image { obtained from svg through process_svg() }
    - [param] w, h        {string} : support w & h { obtained from svg through process_svg() }
    - [param] output_path {string} : path to the destination folder { user defined }
    - [param] coord_edges {list}   : contours coodrinates { obtained from svg through process_svg() }
                                     coord_edges[0] = left contour
                                     coord_edges[1] = right contour
                                     coord_edges[2] = support contour
    - [out] saves 'img_name_Left_Crop.png', 'img_name_Right_Crop.png' and corresponding masks in the specified folder
    - [out] left and right crop path { useful for later operations : homography, visualisation }
    '''


    # Obtention des listes de coordonnées
    coord = coord_edges
    # Récupération de l'image sur laquelle on dessine
    support = cv.imread(input_path)

    if support.size ==0 :
        print("support is not readable in generation crop")
        return 1
    # On crée une image noire de la taille du support
    mask_g = np.zeros([h,w], dtype=np.uint8)
    # On commence par le coté gauche
    coordinates1 = coord[0]
    # Le format supporté par cv.fillPoly est un numpy.array
    pts = np.array(coordinates1, dtype=np.int64) #shape 2 colonnes et plusieurs lignes
    # On remplit ce polygone de blanc (1 en binaire) avec .fillPoly
    cv.fillPoly(mask_g, [pts], (255,255,255))
    # cv.imwrite('mask_g.png', mask_g)
    # On a crée un masque, il n'y a plus qu'à l'appliquer sur l'image
    left_image = cv.bitwise_and(support, support, mask=mask_g)

    # On crée une nouvelle image avec juste l'image masquée!
    #cv.imwrite('left_image.png' , left_image)  # Pour le moment on ne peut pas choisir l'extension de l'image

    # On va faire pareil pour l'image droite
    mask_d = np.zeros([h,w], dtype=np.uint8)
    coordinates2 = coord[1]
    pts = np.array(coordinates2, dtype=np.int64)
    cv.fillPoly(mask_d, [pts], (255,255,255))
    # cv.imwrite('mask_d.png', mask_d)
    right_image = cv.bitwise_and(support, support, mask=mask_d)
    # cv.imwrite('right_image.png', right_image)  # Save the ROI as image of the specified extension

    # On cherche maintenant à couper les images dans un rectangle collé à la zone qui nous intéresse
    # On récupère l'image qui nous intéresse
    before_crop_g = left_image
    before_crop_g_mask = mask_g
    before_crop_d = right_image
    before_crop_d_mask = mask_d

    # Définir les points du polygone gauche
    points_g = np.array(coord[0])
    points_d = np.array(coord[1])

    # Trouver le rectangle englobant le polygone gauche
    rect_g = cv.minAreaRect(points_g)
    box_g = cv.boxPoints(rect_g)
    box_g = np.intp(box_g)

    # Extraire les coordonnées x et y séparément
    x_values_g, y_values_g = box_g[:,0], box_g[:, 1]

    # Trouver les coordonnées du rectangle englobant
    x_g = min(x_values_g)
    y_g = min(y_values_g)
    w_g = max(x_values_g) - min(x_values_g)
    h_g = max(y_values_g) - min(y_values_g)

    # Rogner l'image en fonction des coordonnées du rectangle englobant
    cropped_image_g = before_crop_g[y_g:y_g+h_g, x_g:x_g+w_g]
    cropped_mask_g = before_crop_g_mask[y_g:y_g + h_g, x_g:x_g + w_g]
    # On fait la même chose pour l'image de droite
    # Trouver le rectangle englobant le polygone droit
    rect_d = cv.minAreaRect(points_d)
    box_d = cv.boxPoints(rect_d)
    box_d = np.intp(box_d)
    # Extraire les coordonnées x et y séparément
    x_values_d, y_values_d = box_d[:,0], box_d[:, 1]

    # Trouver les coordonnées du rectangle englobant
    x_d = min(x_values_d)
    y_d = min(y_values_d)
    w_d = max(x_values_d) - min(x_values_d)
    h_d = max(y_values_d) - min(y_values_d)

    # Rogner l'image en fonction des coordonnées du rectangle englobant
    cropped_image_d = before_crop_d[y_d:y_d+h_d, x_d:x_d+w_d]
    cropped_mask_d = before_crop_d_mask[y_d:y_d + h_d, x_d:x_d + w_d]

    # On veut s'assurer maintenant que les deux images font la même taille (utile pour disparity map)
    # Obtenir les dimensions des images
    hauteur_g, largeur_g = cropped_image_g.shape[:2]
    hauteur_d, largeur_d = cropped_image_d.shape[:2]

    # Trouver la plus petite dimension parmi les deux couples de dimensions
    hauteur_min = min(hauteur_g, hauteur_d)
    largeur_min = min(largeur_g, largeur_d)

    # Redimensionner les images pour qu'elles aient la même taille
    cropped_image_g = cv.resize(cropped_image_g, (largeur_min, hauteur_min))
    cropped_image_d = cv.resize(cropped_image_d, (largeur_min, hauteur_min))

    # On fait la même chose pour les masques
    # Obtenir les dimensions des masques
    hauteur_mask_g, largeur_mask_g = cropped_mask_g.shape[:2]
    hauteur_mask_d, largeur_mask_d = cropped_mask_d.shape[:2]

    # Trouver la plus petite dimension parmi les deux couples de dimensions
    hauteur_mask_min = min(hauteur_mask_g, hauteur_mask_d)
    largeur_mask_min = min(largeur_mask_g, largeur_mask_d)

    # Redimensionner les masques pour qu'elles aient la même taille
    cropped_mask_g = cv.resize(cropped_mask_g, (largeur_mask_min, hauteur_mask_min))
    cropped_mask_d = cv.resize(cropped_mask_d, (largeur_mask_min, hauteur_mask_min))

    ## IMAGE SAVING
    _img_name = (((input_path.split('/'))[-1]).split('.'))[0]
    cv.imwrite(output_path+"/"+_img_name + '_Left_Crop.png', cropped_image_g)
    cv.imwrite(output_path+"/"+_img_name+'_Right_Crop.png', cropped_image_d)
    cv.imwrite(output_path+"/"+_img_name+'_Left_Crop_mask.png', cropped_mask_g)
    cv.imwrite(output_path+"/"+_img_name+'_Right_Crop_mask.png', cropped_mask_d)

    return   [output_path+"/"+_img_name + '_Left_Crop.png',
              output_path+"/"+_img_name+'_Right_Crop.png',
              output_path+"/"+_img_name+'_Left_Crop_mask.png',
              output_path+"/"+_img_name+'_Right_Crop_mask.png']
